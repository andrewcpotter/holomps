#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Example: HoloVQE for TFIM using 
Google's Cirq package to create the circuit
Created on Mon Sep 21 16:03:35 2020

@author: acpotter
"""
#%% imports
import numpy as np
#import numpy.linalg as la
#import scipy.optimize as opt
#import scipy.special as special
from scipy.optimize import minimize
import time

# plots
import matplotlib.pyplot as plt
#from mpl_toolkits.mplot3d import axes3d, Axes3D 

# quantum circuits
import cirq
import sympy # for parameterized circuits

# tensor networks
import tenpy as tp
from tenpy.networks.site import SpinHalfSite
from tenpy.networks.mpo import MPO
from tenpy.networks.mps import MPS
import numpy as np


#%% Hyperparameters
J=1.0
g=1.0

#%% Setup qubits
nphys = 1
nbond = 1
qp = [cirq.NamedQubit('p'+str(j)) for j in range(nphys)] # physical qubits
qb = [cirq.NamedQubit('b'+str(j)) for j in range(nbond)] # bond qubits

#%% Setup Tenpy model
site = SpinHalfSite(conserve=None)
Id, Sp, Sm, Sz = site.Id, site.Sp, site.Sm, 2*site.Sz
Sx = Sp + Sm
W = [[Id,Sx,g*Sz], [None,None,-J*Sx], [None,None,Id]]
H = MPO.from_grids([site], [W], bc='infinite', IdL=0, IdR=-1)

#%% setup variational circuit
# define variational parameters as sympy symbols
n_var_params = 15 # number of variational parameters
vpsym = [sympy.Symbol('theta'+str(j)) for j in range(n_var_params)] # list of symbols for circuit parameters

# construct cirq circuit with symbolic parameters
c = cirq.Circuit()
c.append([cirq.H(qp[0]), # arbitrary SU(4) circuit using Cartan decomposition
          # 1q on p qubit
          cirq.rx(vpsym[0])(qp[0]),
          cirq.rz(vpsym[1])(qp[0]),
          cirq.rx(vpsym[2])(qp[0]),
          # 1q on bond qubit
          cirq.rx(vpsym[3])(qb[0]),
          cirq.rz(vpsym[4])(qb[0]),
          cirq.rx(vpsym[5])(qb[0]),
          # cartan sub algebra part
          cirq.XX(qb[0],qp[0]) ** vpsym[6],
          cirq.YY(qb[0],qp[0]) ** vpsym[7],
          cirq.ZZ(qb[0],qp[0]) ** vpsym[8], 
          # 1q on p qubit
          cirq.rx(vpsym[9])(qp[0]),
          cirq.rz(vpsym[10])(qp[0]),
          cirq.rx(vpsym[11])(qp[0]),
          # 1q on bond qubit
          cirq.rx(vpsym[12])(qb[0]),
          cirq.rz(vpsym[13])(qb[0]),
          cirq.rx(vpsym[14])(qb[0]),
          ])

def energy(params,circuit):
    """
    computes energy of parameterized circuit ansatz
    inputs:
      params, np.array() of length = n_var_params, variational parameter values
      circuit, cirq.QuantumCircuit(), parameterized circuit
    outputs:
      holo_E, float, energy of iMPS generated by circuit
    """
    # setup circuit (resolve parameters to numerical values)
    resolver = cirq.ParamResolver({'theta'+str(j):params[j] for j in range(n_var_params)})
    resolved_circuit = cirq.resolve_parameters(circuit, resolver)   
    u = resolved_circuit.unitary(qubit_order = qp+qb)
    unitary = u.reshape([2**nphys,2**nbond,2**nphys,2**nbond])
    # Convert to MPS and compute <H>    
    # change the order of indices to [p, vL, vR] = [p_out, b_in, b_out] 
    # (with p_in = 0 to go from unitary to isometry)
    B = np.swapaxes(unitary[:,:,0,:],1,2)
    psi = MPS.from_Bflat([site], [B], bc='infinite', dtype=complex, form=None)
    psi.canonical_form()
    psi.convert_form(psi.form)
    holo_E = (H.expectation_value(psi)).real
    
    return holo_E

#%% Example holoVQE using cirq-circuits
t0 = time.time()
# optimize the parameter(s)
result = minimize(energy, 
                  x0=0.1*np.random.randn(15), 
                  args=(c), 
                  method='nelder-mead')
opt_params = result.x
holo_E = result.fun;
t2 = time.time()

#%% Output results
#print("time elapsed".format(tf-t1))
print("optimized parameters = {}".format(opt_params))
print("num function evaluations: {}".format(result['nfev']))
print("num iterations: {}".format(result['nit']))
print("termination msg: {}".format(result['message']))
print("holoMPS: E = {:.8}".format(holo_E))
tf = time.time()
print('Elapsed time: {:.4}s'.format(tf-t0))
